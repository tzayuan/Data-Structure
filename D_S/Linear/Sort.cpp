#include "pch.h"
#include "Sort.h"

InSort_SqList* InitRandomSqList() {
	static InSort_SqList R[Sort_MAXITEM];//不加static的话只会返回第一个数值
	for (int i = 0; i < Sort_MAXITEM; i++) {
		int j = random(100);
		R[i].key = j;
	}
	InSort_SqList *RR = R;
	return RR;
}

void DispInitKey(InSort_SqList *R) {
	for (int i = 0; i < Sort_MAXITEM; i++) {
		printf_s("%3d ", R[i].key);
	}
	printf_s("\n");
}

void Bubble_Sort(InSort_SqList *R, int length) {
	int flag, temp;//flag用于记录此趟冒泡是否发生过排序,temp在冒泡过程中发生两两交换时充当中介角色
	for (int i = 0; i < length - 1; i++) {
		flag = 0;//一旦发生过一次交换,则令flag = 1;因此若一趟排序未发生交换,则排序序列两两排好序,因此flag未置为1,for循环结束后,判断flag为0则退出函数,排序完成
		for (int j = 0; j < length - i - 1; j++) {//每一趟使得最大的元素在最右端;
			if (R[j].key > R[j + 1].key) {
				flag = 1;
				temp = R[j].key;
				R[j].key = R[j + 1].key;
				R[j + 1].key = temp;
			}
		}
		if (flag == 0) return;
	}
	return;
}

void Quick_Sort(InSort_SqList * R, int s, int t) {
	//冒泡和快排都是基于交换的思想.都是每一趟排序结束后使得一个元素位于其最终位置,但这个最终位置的不同导致接下来所要排序的序列(即除已有序元素外的元素)的规模发生改变,使得快排和冒泡的复杂度有较大的差距
	//冒泡是每两个相邻的元素进行两两比较最终每一趟冒泡使得一个元素位于其最终位置.具体分析其复杂度,每一趟冒泡的两两比较次数必为序列元素个数减一,
	//	而每一趟冒泡结束后下一趟需冒泡的序列的规模必为当前规模减一【这是快排改进的重点,也是分而治之中分的方式不同所带来的时间复杂度的非线性改变】
	//快排实质上是选取的某一枢纽元素(lomoto取第一个元素为枢纽元素)和从距离其最远的元素开始两两比较交换,
	//	这就使得只有当序列有序时,才会出现两两比较次数为序列元素个数减一的情况(即和冒泡一样了),其余情况两两比较次数必少于序列元素个数减一【注意这个想法似乎错了,每一趟快排的两两比较次数必为序列规模减一】
	//	但是此时实际上有序的元素把序列分成了无序的两个自序列,这两个子序列的规模均小于序列规模减一(极端情况,即序列已有序的情况除外,此时只有一个子序列,这个子序列规模即为序列规模减一)
	//	而两个子序列规模不按照每次减一的速度减少,就使得接下来对子序列的两两比较次数大大减少,即便是两个子序列均按照冒泡来比较,两个比较次数加和也远比从序列规模减一的数每次减一,一直加到1为止的和要小
	//		(如对9个数进行排序,按照冒泡需要8+7+6+5+・・・+1 = 36次比较;而对于快排,只要不是序列已有序的极端情况,若第一次快排(比较次数为8)使得有序的元素是第5个元素,即便是接下来的两个子序列都用冒泡,也只有2*(3+2+1)=12次,总共20次比较,少于36次比较)
	//	因此,快排和冒泡的复杂度差距就体现在这里,即每趟排序结束后下一趟排序所要排序的子序列规模,这个规模的减少,几乎成倍数减少了算法的时间复杂度【这里可以推进一步,给出一定的数学上的比较】
	//	快排就是充分利用了分而治之中的分,使得分后的序列规模不线性减少,然后治的复杂度就不线性减少了
	//
	//最终得到冒泡排序的时间复杂度为:
	//T_best(n) = n;(元素已有序,则比较次数为n-1次)
	//T_worst(n) = n^2;
	//T_average(n) = n^2;
	//空间复杂度为S(n) = O(1),即充当中介角色的temp
	//快速排序的时间复杂度为:
	//T_best(n) = nlog2(n);
	//T_worst(n) = n^2;(元素已有序,则每次排好序的元素位置为序列头,就和冒泡一样了,因为每次排序后子序列只有一个且规模为当前序列规模减一,没有非线性的减少,因此时间复杂度并未比冒泡优化)
	//T_average(n) = nlog2(n);
	//空间复杂度S(n) = nlog2(n),与递归的层数有关,最多递归nlog2(n)层【此处有疑惑,未经过计算检验】
	if (s < t) {//递归边界,使得递归完能够退出函数
		int i = s, j = t;//i从左往右扫,j从右往左扫
		InSort_SqList pivot = R[i];//枢纽元素设为当前排序序列的第一个元素
		while (i < j) {
			while (R[j].key > pivot.key && i < j) {//因为没有取等号,因此当枢纽元素和当前扫描到的元素key值相同时,退出循环,此时i和j的值满足i<j,因此把key值相同的两个元素交换了,因此该算法不稳定
				j--;
			}
			if (i < j) {
				R[i] = R[j];
				i++;
			}//此时j的右边的所有元素key值都大于pivot的key值
			while (R[i].key < pivot.key && i < j) {
				i++;
			}
			if (i < j) {
				R[j] = R[i];
				j--;
			}//此时i的左边的所有元素key值都小于pivot的key值
			R[i] = pivot;//此时i = j,同时此时i所指向元素的key值大于其左侧所有元素的key值且小于其右侧所有元素的key值,即该pivot的最终位置为i,因此执行此操作使得pivot元素置于其最终位置
		}
		DispInitKey(R);
		Quick_Sort(R, s, i - 1);//对此时所进入函数体的自序列的pivot最终位置的左子序列进行快速排序,使左边序列的首元素置于其最终位置并对首元素最终位置的左右两边子序列递归快排,直至不满足s<t(递归边界)
		Quick_Sort(R, i + 1, t);//对此时所进入函数体的子序列的pivot最终位置的右子序列进行快速排序,使右边序列的首元素置于其最终位置并对首元素最终位置的左右两边子序列递归快排,直至不满足s<t(递归边界)
	}
	else {
		return;
	}
}

void Insert_Sort(InSort_SqList * R, int length) {
	//直接插入排序
	//对于一个给定无序序列,我们依次遍历该序列的每一个结点,并将序列分为前半部分的有序序列和后半部分的无序序列
	//由此规则,我们假定第一个元素已有序,因此i从下标为1的元素开始遍历,一直遍历到下标为length - 1的元素,将当前遍历到的(即要插入到有序序列的当前遍历元素)保存到temp变量中
	//用j依次遍历与i紧邻的前一个元素(j=i-1)往前直至下标为0的元素,若本次比较结果为i关键字较小,则i在当前j元素的前面,
	//	因此j元素需要向后移动一个位置,即R[j+1]=R[j],同时j向前移动一个位置至下一个未比较元素处继续循环比较,
	//	直至当前j元素关键字值小于i元素关键字值,则说明i要插入的位置为j元素的后面(因为j元素所在的序列已为有序序列,因此j元素之前的元素关键字值必定小于等于j元素的关键字值)
	//	此时退出循环,将i插入到j元素的后面,即R[j + 1] = temp,则表示本次插入排序完成,使得前半部分的有序序列规模加一,无序序列的规模减一,按照for循环i自加1正好顺次遍历当前无序序列的第一个元素.
	//	直至i遍历完全部无序序列,算法结束,当前序列为全部有序序列
	InSort_SqList temp;
	for (int i = 1; i < length; i++) {
		temp = R[i];
		int j = i - 1;
		while (j >= 0 && temp.key < R[j].key) {
			R[j + 1] = R[j];
			j--;
		}
		R[j + 1] = temp;
	}
}

void Shell_Sort(InSort_SqList * R, int length) {
	//希尔排序
	int gap = length / 2;
	InSort_SqList temp;
	while (gap > 0) {
		//while里面的程序段与直接插入排序的程序段和思想基本一致,区别是希尔排序在向前比较时,不是一个一个向前比较,而是隔gap个元素比较一个,因此j每次不是减1,而是减gap.
		//可以看出,当gap为1时,希尔排序与冒泡全过程则一致.
		//	gap的意义,相当于把整个序列分成gap个子序列,对每个子序列进行直接插入排序.则i从gap开始向后遍历,保证每组子序列都会被直接排序到.
		for (int i = gap; i < length; i++) {
			temp = R[i];
			int j = i - gap;
			while (j >= 0 && temp.key < R[j].key) {
				R[j + gap] = R[j];
				j = j - gap;
			}
			R[j + gap] = temp;
		}
		gap = gap / 2;
	}
}