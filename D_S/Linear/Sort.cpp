#include "pch.h"
#include "Sort.h"

InSort_SqList* InitRandomSqList() {
	static InSort_SqList R[Sort_MAXITEM];//不加static的话只会返回第一个数值
	for (int i = 0; i < Sort_MAXITEM; i++) {
		int j = random(100);
		R[i].key = j;
	}
	InSort_SqList *RR = R;
	return RR;
}

void DispInitKey(InSort_SqList *R) {
	for (int i = 0; i < Sort_MAXITEM; i++) {
		printf_s("%3d ", R[i].key);
	}
	printf_s("\n");
}

void Bubble_Sort(InSort_SqList *R, int length) {
	int flag, temp;//flag用于记录此趟冒泡是否发生过排序,temp在冒泡过程中发生两两交换时充当中介角色
	for (int i = 0; i < length - 1; i++) {
		flag = 0;//一旦发生过一次交换,则令flag = 1;因此若一趟排序未发生交换,则排序序列两两排好序,因此flag未置为1,for循环结束后,判断flag为0则退出函数,排序完成
		for (int j = 0; j < length - i - 1; j++) {//每一趟使得最大的元素在最右端;
			if (R[j].key > R[j + 1].key) {
				flag = 1;
				temp = R[j].key;
				R[j].key = R[j + 1].key;
				R[j + 1].key = temp;
			}
		}
		if (flag == 0) return;
	}
	return;
}

void Quick_Sort(InSort_SqList * R, int s, int t) {
	//冒泡和快排都是基于交换的思想.都是每一趟排序结束后使得一个元素位于其最终位置,但这个最终位置的不同导致接下来所要排序的序列(即除已有序元素外的元素)的规模发生改变,使得快排和冒泡的复杂度有较大的差距
	//冒泡是每两个相邻的元素进行两两比较最终每一趟冒泡使得一个元素位于其最终位置.具体分析其复杂度,每一趟冒泡的两两比较次数必为序列元素个数减一,
	//	而每一趟冒泡结束后下一趟需冒泡的序列的规模必为当前规模减一【这是快排改进的重点,也是分而治之中分的方式不同所带来的时间复杂度的非线性改变】
	//快排实质上是选取的某一枢纽元素(lomoto取第一个元素为枢纽元素)和从距离其最远的元素开始两两比较交换,
	//	这就使得只有当序列有序时,才会出现两两比较次数为序列元素个数减一的情况(即和冒泡一样了),其余情况两两比较次数必少于序列元素个数减一【注意这个想法似乎错了,每一趟快排的两两比较次数必为序列规模减一】
	//	但是此时实际上有序的元素把序列分成了无序的两个自序列,这两个子序列的规模均小于序列规模减一(极端情况,即序列已有序的情况除外,此时只有一个子序列,这个子序列规模即为序列规模减一)
	//	而两个子序列规模不按照每次减一的速度减少,就使得接下来对子序列的两两比较次数大大减少,即便是两个子序列均按照冒泡来比较,两个比较次数加和也远比从序列规模减一的数每次减一,一直加到1为止的和要小
	//		(如对9个数进行排序,按照冒泡需要8+7+6+5+···+1 = 36次比较;而对于快排,只要不是序列已有序的极端情况,若第一次快排(比较次数为8)使得有序的元素是第5个元素,即便是接下来的两个子序列都用冒泡,也只有2*(3+2+1)=12次,总共20次比较,少于36次比较)
	//	因此,快排和冒泡的复杂度差距就体现在这里,即每趟排序结束后下一趟排序所要排序的子序列规模,这个规模的减少,几乎成倍数减少了算法的时间复杂度【这里可以推进一步,给出一定的数学上的比较】
	//	快排就是充分利用了分而治之中的分,使得"分"的过程中序列规模不线性减少,然后在"治"时复杂度就不线性减少,而是更快速度减少.
	//
	//最终得到冒泡排序的时间复杂度为:
	//T_best(n) = n;(元素已有序,则比较次数为n-1次)
	//T_worst(n) = n^2;
	//T_average(n) = n^2;
	//空间复杂度为S(n) = O(1),即充当中介角色的temp
	//快速排序的时间复杂度为:
	//T_best(n) = nlog2(n);
	//T_worst(n) = n^2;(元素已有序,则每次排好序的元素位置为序列头,就和冒泡一样了,因为每次排序后子序列只有一个且规模为当前序列规模减一,没有非线性的减少,因此时间复杂度并未比冒泡优化)
	//T_average(n) = nlog2(n);
	//空间复杂度S(n) = nlog2(n),与递归的层数有关,最多递归nlog2(n)层【此处有疑惑,未经过计算检验】
	if (s < t) {//递归边界,使得递归完能够退出函数
		int i = s, j = t;//i从左往右扫,j从右往左扫
		InSort_SqList pivot = R[i];//枢纽元素设为当前排序序列的第一个元素
		while (i < j) {
			while (R[j].key > pivot.key && i < j) {//因为没有取等号,因此当枢纽元素和当前扫描到的元素key值相同时,退出循环,此时i和j的值满足i<j,因此把key值相同的两个元素交换了,因此该算法不稳定
				j--;
			}
			if (i < j) {
				R[i] = R[j];
				i++;
			}//此时j的右边的所有元素key值都大于pivot的key值
			while (R[i].key < pivot.key && i < j) {
				i++;
			}
			if (i < j) {
				R[j] = R[i];
				j--;
			}//此时i的左边的所有元素key值都小于pivot的key值
			R[i] = pivot;//此时i = j,同时此时i所指向元素的key值大于其左侧所有元素的key值且小于其右侧所有元素的key值,即该pivot的最终位置为i,因此执行此操作使得pivot元素置于其最终位置
		}
		DispInitKey(R);
		Quick_Sort(R, s, i - 1);//对此时所进入函数体的自序列的pivot最终位置的左子序列进行快速排序,使左边序列的首元素置于其最终位置并对首元素最终位置的左右两边子序列递归快排,直至不满足s<t(递归边界)
		Quick_Sort(R, i + 1, t);//对此时所进入函数体的子序列的pivot最终位置的右子序列进行快速排序,使右边序列的首元素置于其最终位置并对首元素最终位置的左右两边子序列递归快排,直至不满足s<t(递归边界)
	}
	else {
		return;
	}
}

void Insert_Sort(InSort_SqList * R, int length) {
	//直接插入排序
	//对于一个给定无序序列,我们依次遍历该序列的每一个结点,并将序列分为前半部分的有序序列和后半部分的无序序列
	//需要注意,对于一个初始无序序列,插入排序中,初始有序子序列为下标为0的元素,初始无序子序列为下标为1~下标为length-1的元素----需要区别于直接选择排序
	//由此规则,我们假定第一个元素已有序,因此i从下标为1的元素开始遍历,一直遍历到下标为length - 1的元素,将当前遍历到的(即要插入到有序序列的当前遍历元素)保存到temp变量中
	//用j依次遍历与i紧邻的前一个元素(j=i-1)往前直至下标为0的元素,若本次比较结果为i关键字较小,则i在当前j元素的前面,
	//	因此j元素需要向后移动一个位置,即R[j+1]=R[j],同时j向前移动一个位置至下一个未比较元素处继续循环比较,
	//	直至当前j元素关键字值小于i元素关键字值,则说明i要插入的位置为j元素的后面(因为j元素所在的序列已为有序序列,因此j元素之前的元素关键字值必定小于等于j元素的关键字值)
	//	此时退出循环,将i插入到j元素的后面,即R[j + 1] = temp,则表示本次插入排序完成,使得前半部分的有序序列规模加一,无序序列的规模减一,按照for循环i自加1正好顺次遍历当前无序序列的第一个元素.
	//	直至i遍历完全部无序序列,算法结束,当前序列为全部有序序列
	InSort_SqList temp;
	for (int i = 1; i < length; i++) {
		temp = R[i];
		int j = i - 1;
		while (j >= 0 && temp.key < R[j].key) {
			R[j + 1] = R[j];
			j--;
		}
		R[j + 1] = temp;
	}
}

void Shell_Sort(InSort_SqList * R, int length) {
	//希尔排序
	int gap = length / 2;
	InSort_SqList temp;
	while (gap > 0) {
		//while里面的程序段与直接插入排序的程序段和思想基本一致,区别是希尔排序在向前比较时,不是一个一个向前比较,而是隔gap个元素比较一个,因此j每次不是减1,而是减gap.
		//可以看出,当gap为1时,希尔排序与冒泡全过程则一致.
		//	gap的意义,相当于把整个序列分成gap个子序列,对每个子序列进行直接插入排序.则i从gap开始向后遍历,保证每组子序列都会被直接排序到.
		for (int i = gap; i < length; i++) {
			temp = R[i];
			int j = i - gap;
			while (j >= 0 && temp.key < R[j].key) {
				R[j + gap] = R[j];
				j = j - gap;
			}
			R[j + gap] = temp;
		}
		gap = gap / 2;
	}
}

void Select_Sort(InSort_SqList * R, int length) {
	//直接选择排序
	//按照找最小值,与无序区首部交换的思想则不稳定: 排序前: 2,4,4*,3 排序后: 2,3,4*,4
	//Q:怎样修改能使它稳定？
	//	在假设当前记录i为最小记录,扫描所有剩余记录寻找更小记录的时候,不仅寻找最小记录而且寻找相同记录,并用数组SameArr记录下相同记录的位置(包括i,把i放数组首元素),
	//	扫描结束后找到最小记录的位置j,将数组SameArr中的最后一个与最小记录交换,然后倒序依次交换数组中的记录.
	//	Example:我们有序列:8*** 3 8** 5 8* 4 8 1 9;第一次扫描后,SameArr中保存了[0, 2, 4, 6]四个位置,
	//	而最小记录为1(其位置为7),于是我们交换序列位置6和位置7的元素,然后按数组SameArr的倒序依次交换里面位置的元素与最小元素,比如交换4和7,(因为前面6和7已经换过),等等等，
	//	最后得到序列:1 8*** 3 8** 5 8* 4 8 9;这样就不会改变相对次序.
	//Reference:https://blog.csdn.net/yishengguoke/article/details/87518054
	InSort_SqList temp;
	for (int i = 0; i < length - 1; i++) {//i的一层含义代表需要对无序区的length-1个元素进行排序(因为每次都选最小的和无序区第一个元素交换,因此无序区只剩下一个元素时一定为最大元素),
		int k = i;//k用以存储无序区最小元素的下标,每一趟选择排序的最开始假定无序区第一个元素为最小元素
		for (int j = i + 1; j < length; j++) {//对无序区扫描以找到当前无序区最小元素,因已假定下标为i的元素(即无序区第一个元素)为最小元素,因此从下标为i+1的元素开始与下标为i的元素比较即可,直至序列最后一个元素,即选出当前无序序列的最小元素.
			if (R[j].key < R[k].key) {
				k = j;
			}
		}
		temp = R[k];//将当前趟无序序列的最小元素与无序序列的第一个元素相交换,则使得有序序列规模加一,即增加了有序序列的最后一个元素(成为有序区最大元素),而无序序列减少了一个最大元素,
		R[k] = R[i]; //同时上一次无序区第一个元素移动到了上一次无序区最小位置处.
		R[i] = temp; //特殊的, 当上一次无序区第一个元素就是最小元素时, 执行该交换后相当于整个序列所有元素位置没变, 但实质上整个序列的有序区规模已加1, 而无序区的规模已减1.
	}
}

void Sift(InSort_SqList * R, int low, int high) {
	//建立大根堆的算法
	int i = low, j = 2 * i;
	InSort_SqList temp = R[i];//将当前所遍历的二叉树的根结点保存,即要被筛选的结点
	while (j <= high) {//表示i至少有左孩子结点
		if (j < high && R[j].key < R[j + 1].key) {//表示i首先有右孩子结点,其次且右孩子结点大于左孩子结点 两者递进全部满足的情况下取大的孩子结点的下标
			j++;
		}
		if (R[j].key > temp.key) {//若当前i结点的关键字值小于较大的的孩子结点的关键字值,则将较大的孩子结点移动至父母结点处,并使得i指向该结点,j指向该结点的左孩子结点,以便重新进入while循环以对以该结点为根结点的子二叉树继续进行调整
			R[i] = R[j];
			i = j;
			j = 2 * i;
		}
		else break;//即筛选结束.情况1)i只有左孩子且左孩子关键字值小于等于i的关键字值;情况2)i左右孩子均有但以i为根结点的子树已满足大根堆的特性
	}
	R[i] = temp;//将筛选结点放入最终位置
}

void Heap_Sort(InSort_SqList * R, int length) {
	//对已经初始化为大根堆的序列R进行堆排序,逐个添加(交换)最大关键字值(即为当前首元素/根结点)的元素至有序子序列(即当前尾元素),
	//再对每次规模减1的无序序列的根结点进行重新建堆,直至整个无序序列只剩下一个元素,即为首元素,
	//因每次向有序序列添加的是当前无序序列的最大元素,因此此时无序序列的唯一一个元素必为关键字值最小的元素,堆排序完成.
	InSort_SqList temp;
	for (int i = length / 2 - 1; i >= 0; i--) {//从最后一个分支结点开始循环建立初始堆直至整个序列的根结点,使得整个序列所构成的完全二叉树所有分支结点均满足大根堆的性质(即所有分支结点均大于其左右孩子).
		Sift(R, i, length - 1);
	}
	for (int i = length - 1; i >= 1; i--) {//依次交换整个序列的首个结点(即大根堆的根结点,即整个序列的最大值)和当前无序序列的最后一个结点,则使得序列分为无序区(前半部分)和有序区(后半部分,且有序区从后往前建立)
		temp = R[0];
		R[0] = R[i];
		R[i] = temp;
		//哪个分支结点变化了,则需要对哪个分支结点进行重新建堆过程,因上面将整个序列的根结点改变,因此对跟整个序列的结点进行重新堆调整
		Sift(R, 0, i - 1);//关于i-1,以第一次为例,第一次交换根结点和最后一个结点后,最后一个结点成为有序区的第一个结点,也是有序区的最后一个结点,而建堆只对无序序列建堆,因此建堆的范围为0~i-1;
	}
}

void Merge(InSort_SqList * R, int low, int mid, int high) {
	//当前传入的序列结合low,mid,high的范围限定,便表示了要合并的两个相邻子序列,第一个子序列为R中下标为low~mid的元素,第二个子序列为R中下标为mid+1~high的元素.
	//具体地,我们通过两个游标i和j分别从两个相邻子序列的第一个元素开始遍历,每次比较当前i和j所指向的元素,选出此次比较中i和j所指向的元素关键字值较大的
	//	(特殊的,当此时i和j所指向的元素的关键字值相等时,则将等号的情况放在大于或小于任意一种里面即可,因为所编写的程序的执行规则限定只有当此时某游标所指向的元素添加至R1后该游标才向后移动,而另外一个游标,虽指向相同关键字值的元素,但由于未添加进R1,所以并不会移动)
	//某一个游标遍历完它所在的子序列,即该子序列的所有元素已经全部添加至R1后,另一游标必定未遍历完它所在的子序列,即该子序列的元素还未全部添加至R1,因此将未遍历完的这个子序列剩余元素依次添加至R1即可,此时即完成了本趟归并排,即R中下标为low~high的部分已有序.
	//最后将两个子序列归并有序后的序列R1依次复制回原R1即可.
	InSort_SqList *R1;
	int i = low, j = mid + 1, k = 0;
	R1 = (InSort_SqList *)malloc((high - low + 1) * sizeof(InSort_SqList));
	while (i <= mid && j <= high) {
		if (R[i].key <= R[j].key) {
			R1[k++] = R[i++];
		}
		else {
			R1[k++] = R[j++];
		}
	}
	while (i <= mid) {
		R1[k++] = R[i++];
	}
	while (j <= high) {
		R1[k++] = R[j++];
	}
	for (int i = low, k = 0; i <= high; k++, i++) {
		R[i] = R1[k];
	}
}

void MergePass(InSort_SqList * R, int subLength, int length) {
	//
	int i;
	for (i = 0; i + 2 * subLength - 1 < length; i = i + 2 * subLength) {
		Merge(R, i, i + subLength - 1, i + 2 * subLength - 1);
	}
	if (i + subLength - 1 < length) {
		Merge(R, i, i + subLength - 1, length - 1);
	}
}

void MergeSort(InSort_SqList * R, int length) {
	//2路归并排序,【2】路的含义是每次将相邻的每【2】个子序列规模排序,【n】路归并为每次将相邻的【n】个子序列规模排序(需深入:n的选取限制及n的取值对时/空复杂度的影响等)
	//最开始把length个元素看作length个有序序列,则每个有序序列的规模为1,每两个相邻的有序序列进行归并排序,则每两个规模为1的有序序列归并为一个规模为2的有序序列
	//则第一趟归并完毕后,整个序列变成了相邻的规模为2的有序序列(未进行排序操作时,即便肉眼可见有序,从排序完成的角度来看,也认为是无序),对每一对相邻的规模为2的有序序列进行归并排序,则每两个规模为2的有序序列归并为一个规模为4的有序序列
	//依次归并下去,使得每趟归并排序后有序子序列的规模变为原来的两倍(特殊的,可能存在最后一个有序子序列规模小于这个两倍的规模)
	//直至最后一次整个序列分为两个有序子序列,则对这两个有序子序列进行Merge后,即完成了对整个序列的排序.
	for (int subLength = 1; subLength < length; subLength = 2 * subLength) {
		MergePass(R, subLength, length);
	}
}